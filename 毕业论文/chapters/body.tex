
%=======第二章=================================
\newpage

\chapter{不确定图中最优生成树和次优生成树求解算法}
\vskip 0.3cm

\section{问题定义}
\label{sec:chap2definition}

\begin{definition}[不确定图]
\label{def:2.1}
不确定图是一个四元组$\mathcal{G} = (V, E, W, P)$，
其中$V$是顶点集，$E$是边集，
$W = \{w(e) \,|\,  e \in E, w(e) \in  \mathbb{N}^{+} \}$是边的权重集，
$P = \{p(e) \,|\,  e \in E, p(e) \in (0, 1]\}$是边存在可能性的集合。
\end{definition}

\begin{definition}[蕴含图]
\label{def:2.2}
令不确定图$\mathcal{G} = (V, E, W, P)$，
若确定图$G=(V_G,E_G,W_G)$是$\mathcal{G}$的一个蕴含图，
则必然满足${V_G}=V$，${E_G}\subseteq E$和${W_G}=\{w(e)|e\in {E_G}\}\subseteq W$。
\end{definition}

从定义~\ref{def:2.1}可知，
不确定图$\mathcal{G} = (V, E, W, P)$每条边以$p(e)$的概率存在，
在可能世界模型下，每条边有存在和不存在两种可能性，所以可以派生出$2^{|E|}$个蕴含图。
本文沿用文献[5, 8, 12]对不确定图模型所做的假设，即不确定图中不同边的概率分布相互独立。
将蕴含图$G$和不确定图$\mathcal{G}$之间的关系表示为$\mathcal{G}\Rightarrow G$。
基于以上假设，蕴含图$G$存在的概率为
\begin{equation}
\label{eq:2.1}
\Pr(\mathcal{G} \Rightarrow G) = \prod_{e\in E_G}p(e) \prod_{e\in E\setminus E_G}(1-p(e)).
\end{equation}


记不确定图$\mathcal{G}$的所有蕴含图的集合为$Imp(\mathcal{G})$。
由文献[6]可知$\mathcal{G}$中所有蕴含图出现的概率和为1，即
\begin{equation}
\label{eq:2.2}
\sum\limits_{G\in Imp(\mathcal{G})}{Pr(\mathcal{G}\Rightarrow G)}=1.
\end{equation}

\begin{example}
图~\ref{fig1:subfiga}为一个不确定图$\mathcal{G}_{1}$，
边上的两个数字分别代表权值和概率，
由于该不确定图有五条可能出现的边，因此该不确定图有$2^5$个蕴含图。
图\ref{fig1:subfigb}为不确定图$\mathcal{G}_{1}$的一个蕴含图，
显然该蕴含图存在的概率为$p(e_2)\times p(e_3)\times p(e_4)\times p(e_5)\times (1-p(e_1)))= 0.03528$。
\end{example}

\begin{figure}[htb]
\centering
\label{fig1}
\subfigure[]{
    \label{fig1:subfiga}
    \begin{minipage}[t]{\figwidth}
    \centering
    \includegraphics[width=\figwidth]{Fig1a}
    \end{minipage}}
\subfigure[]{
    \label{fig1:subfigb}
    \begin{minipage}[t]{\figwidth}
    \centering
    \includegraphics[width=\figwidth]{Fig1b}
    \end{minipage}}
\subfigure[]{
    \label{fig1:subfigc}
    \begin{minipage}[t]{\figwidth}
    \centering
    \includegraphics[width=\figwidth]{Fig1c}
    \end{minipage}}
\caption{Example 1:
(a) uncertain graph $\mathcal{G}_{1}$;
(b) an implicated graph from $\mathcal{G}_{1}$;
(c) main implicated graph from $\mathcal{G}_{1}$.}
\end{figure}

在传统图论中，图的最小生成树被定义为边的权值和最小的生成树，
一个图可能存在多个最小生成树，这些最小生成树具有相同的权值和。
然而在不确定图中，每条边都有一个存在的概率，
这样会导致每一颗最小生成树都只有一定的概率存在，
我们可以通过一个稳定性来区分最小生成树的好坏，即
\begin{equation}
\label{eq:2.3}
R_T = \prod_{e\in E_T}p(e)
\end{equation}

公式~\ref{eq:2.3}的含义与公式~\ref{eq:2.1}有所不同，
公式~\ref{eq:2.3}的另一层含义可以解释为所有包含最小生成树$T$的蕴含图存在的概率和。

为了区分每颗生成树，我们需要给每个生成树进行编号，
假设所有生成树的边都按照编号从小到大进行排序，我们称字典序较小的生成树具有更小的编号。

\begin{definition}[最小生成树]
\label{def:2.3}
设不确定图$\mathcal{G}=(V,E,W,P)$，若生成树$T$满足$\forall T'(\sum_{e \in E_T} W(e) \le \sum_{e' \in E_{T'}}W(e'))$，
则称$T$为不确定图$\mathcal{G}$的最小生成树，记编号最小的最小生成树为$T_M^{\mathcal{G}}$，
其边集为$E_M^{\mathcal{G}}$，边的权值和为$W_M^{\mathcal{G}}$。
\end{definition}

\begin{definition}[最小最大乘积生成树]
\label{def:2.4}
设不确定图$\mathcal{G}=(V,E,W,P)$，若生成树$T$满足$\forall T'(\prod_{e \in E_T} P(e) \le \prod_{e' \in E_{T'}}P(e'))$，
则称$T$为不确定图$\mathcal{G}$的最小乘积生成树，记编号最小的最小乘积生成树为$T_{PL}^{\mathcal{G}}$，
其边集为$E_{PL}^{\mathcal{G}}$，边的权值和为$W_{PL}^{\mathcal{G}}$。
若生成树$T$满足$\forall T'(\prod_{e \in E_T} P(e) \ge \prod_{e' \in E_{T'}}P(e'))$，
则称$T$为不确定图$\mathcal{G}$的最大乘积生成树，记编号最小的最大乘积生成树为$T_{PB}^{\mathcal{G}}$，
其边集为$E_{PB}^{\mathcal{G}}$，边的权值和为$W_{PB}^{\mathcal{G}}$
\end{definition}

\begin{definition}[最优生成树]
\label{def:2.5}
设$Imp(\mathcal{T})$为不确定图$\mathcal{G}$中所有最小生成树的集合，
若最小生成树$T$满足$\forall T' \in Imp(\mathcal{T})(R_{T'} \le R_T)$，
则称$T$为不确定图$\mathcal{G}$的最优生成树。记编号最小的最优生成树为$T_O^{\mathcal{G}}$，
其边集为$E_O^{\mathcal{G}}$，边的权值和为$W_O^{\mathcal{G}}$。
\end{definition}

显然，最优生成树不是唯一的，我们也可以将最优生成树看作不确定图中的最小生成树中的最小乘积生成树。


\section{最优生成树算法}
\label{sec:chap2algorithm}

\begin{theorem}
\label{trm:2.2.1}
设不确定图$\mathcal{G}=(V,E,W,P)$和$\mathcal{G}'=(V,E,W,P')$，其满足$P'(e) = \log_2 (P(e))$，
则$W_{PL}^{\mathcal{G}} = 2^{W_M^{\mathcal{G}'}}$。
\end{theorem}

\begin{proof}
设$T$为$\mathcal{G}$和$\mathcal{G}'$的任意一颗生成树，其边集为$E_T$，则$\sum_{e \in E_T}P'(e) = \log_2 \prod_{e \in E_T}P(e)$，
显然生成树$T$在$\mathcal{G}'$中的边权和与在$\mathcal{G}$中边权的乘积成正比，
当$T$为$\mathcal{G}'$的最小生成树时，则有$W_M^{\mathcal{G}'} = \log_2 W_{PL}^{\mathcal{G}}$，即$W_{PL}^{\mathcal{G}} = 2^{W_M^{\mathcal{G}'}}$。
\end{proof}

由定理~\ref{trm:2.2.1}可知，要想求得最小乘积生成树，
可以将图中所有边的权值进行$\log$变换，然后求新图的最小生成树。
我们将在后面使用该思路去求解不确定图的最优生成树。

\begin{corollary}
\label{cor:2.2.1}
若生成树的边权和是最小的，那么其边权的乘积也是最小的；
若生成树的边权和是最大的，那么其边权的乘积也是最大的。
\end{corollary}

我们知道使用$kruskal$算法求解最小生成树的第一步是需要对图中所有的边进行排序，
因此我们可以假设不确定图$\mathcal{G} = (V,E,W,P)$中所有的边按照如下优先级进行排序：

\begin{itemize}
 \item 将权值较小的边排在前面；
 \item 对于权值相同的边，则将概率较大的边排在前面；
 \item 若两者的值都相同，则将编号较小的边排在前面。
\end{itemize}

最优生成树的算法步叭缦拢
\begin{enumerate}
 \item 新建一个不确定图$\mathcal{G}'$，其顶点集和不确定图$\mathcal{G}$相同，边集为空；
 \item 假设不确定图$\mathcal{G}$的边集已经按照上面的规则进行排序；
 \item 依次处理排序好的边，若这条边连接的两个顶点不在同一个连通分量中，则将这条边加入不确定图$\mathcal{G}'$;
 \item 重复第3步，直到不确定图$\mathcal{G}'$中所有的顶点都连通。
\end{enumerate}
这样，我们得到的不确定图$\mathcal{G}'$既是不确定图$\mathcal{G}$的最优生成树,
显然该最优生成树也是编号最小的最优生成树$T_O^{\mathcal{G}}$。

\begin{theorem}
\label{trm:2.2.2}
最优生成树算法是正确的。
\end{theorem}

\begin{proof}
显然最优生成树的算法步昂$Kruskal$算法的步耙恢拢因此我们得到的生成树一定是最小生成树。
根据最小生成树的性质，所有的最小生成树应该具有相同的边权值序列（假设边权值按照从小到大排序），
并且相同权值的边构成的连通分量应该相同，
根据最优生成树算法可知，由相同权值的边构成的连通分量，其边的概率和是最大的。
再由推论~\ref{cor:2.2.1}可知，这些边的概率乘积也是最大的，
因此最优生成树算法是正确的。
\end{proof}

\begin{example}
图~\ref{fig2}为一个不确定图$\mathcal{G}$，按照优先级排序后的边集为$\{e_1,e_2, \cdots, e_{10}\}$。
图~\ref{fig3}为图~\ref{fig2}中不确定图的最优生成树求解过程，
红色标记的边为加入生成树中的边，
在图(2)到图(3)时，由于顶点$D$和顶点$E$已经在同一个连通分量，
所以边$e_3$没有加入生成树的边集中，图(6)中红线构成的生成树则为最优生成树。
从图中可知，$W_O^{\mathcal{G}} = 13$且$R_{T_O^{\mathcal{G}}} = 0.14112$。
\end{example}

\begin{figure}[htb]
\label{fig2}
\centering
\includegraphics[width=\imagewidth]{Fig2}
\caption{Example 2: 不确定图$\mathcal{G}$。}
\end{figure}

\begin{figure}[htb]
\label{fig3}
\centering
\includegraphics[width=\textwidth]{Fig3}
\caption{Example 2: 最优生成树计算过程。}
\end{figure}

\begin{algorithm}[!htb]
\caption{最优生成树算法}
\label{alg:ost}
\begin{algorithmic}[1]
\Statex
\setcounter{ALG@line}{0}
\Algphase{\textbf{模块1：}并查集}
\Statex \textbf{initialization} $RT_i\gets i(i = 1,2,\cdots,|V|)$
\Procedure{GetRoot}{$u$}
\If {$u=RT_u$}
    \Return $u$
\Else {} \Return ($RT_u\gets \Call{GetRoot}{RT_u}$)
\EndIf
\EndProcedure
\setcounter{ALG@line}{0}
\Algphase{\textbf{模块2： }最优生成树算法}
\Procedure{OST}{$\mathcal{G}$} \Comment $\mathcal{G}=(V,E,W,P)$
\State $E_O^{\mathcal{G}} = \emptyset$
\For {\textbf{each} $e_i \gets (u,v) \in E$}
    \State $ru \gets \Call{GetRoot}{u}$
    \State $rv \gets \Call{GetRoot}{v}$
    \If{$ru \ne rv$}
        \State $RT_{ru} = rv$
        \State $E_O^{\mathcal{G}} = E_O^{\mathcal{G}} \cup \{e_i\}$
    \EndIf
\EndFor
\State \textbf{return} $E_O^{\mathcal{G}}$
\EndProcedure
\end{algorithmic}
\end{algorithm} 